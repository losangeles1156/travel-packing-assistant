-- Enable necessary extensions
create extension if not exists "uuid-ossp";

-- Table: users
create table if not exists users (
    user_id text primary key,
    first_seen timestamptz not null default now(),
    last_seen timestamptz not null default now(),
    locale text,
    user_agent text
);

-- Table: sessions
create table if not exists sessions (
    session_id text primary key,
    user_id text not null references users(user_id) on delete cascade,
    started_at timestamptz not null default now(),
    last_seen timestamptz not null default now()
);

-- Table: events
create table if not exists events (
    id bigint generated by default as identity primary key,
    user_id text not null,
    session_id text not null,
    name text not null,
    payload jsonb,
    created_at timestamptz not null default now()
);
-- Indexes for events
create index if not exists idx_events_created_at on events(created_at);
create index if not exists idx_events_name_created_at on events(name, created_at);
create index if not exists idx_events_session_created_at on events(session_id, created_at);

-- Table: shared_lists
create table if not exists shared_lists (
    share_id text primary key,
    snapshot jsonb not null,
    created_at timestamptz not null default now()
);
create index if not exists idx_shared_lists_created_at on shared_lists(created_at);

-- Table: collab_sessions
create table if not exists collab_sessions (
    id uuid primary key default uuid_generate_v4(),
    snapshot jsonb not null,
    version int not null default 1,
    last_active timestamptz not null default now()
);

-- RLS for collab_sessions
alter table collab_sessions enable row level security;

create policy "Enable select for everyone" on collab_sessions for select using (true);
create policy "Enable insert for everyone" on collab_sessions for insert with check (true);
create policy "Enable update for everyone" on collab_sessions for update using (true);

-- RPC: Upsert User
create or replace function upsert_user(
    p_user_id text,
    p_locale text,
    p_user_agent text
) returns void as $$
begin
    insert into users (user_id, last_seen, locale, user_agent)
    values (p_user_id, now(), p_locale, p_user_agent)
    on conflict (user_id) do update set
        last_seen = now(),
        locale = coalesce(excluded.locale, users.locale),
        user_agent = coalesce(excluded.user_agent, users.user_agent);
end;
$$ language plpgsql;

-- RPC: Upsert Session
create or replace function upsert_session(
    p_session_id text,
    p_user_id text
) returns void as $$
begin
    insert into sessions (session_id, user_id, started_at, last_seen)
    values (p_session_id, p_user_id, now(), now())
    on conflict (session_id) do update set
        last_seen = now();
end;
$$ language plpgsql;

-- RPC: Cleanup Old Data
create or replace function cleanup_old_data(
    p_share_ttl_days int,
    p_event_retention_days int
) returns jsonb as $$
declare
    v_shared_deleted int;
    v_events_deleted int;
    v_sessions_deleted int;
    v_users_deleted int;
    v_shared_threshold timestamptz;
    v_event_threshold timestamptz;
begin
    v_shared_threshold := now() - (p_share_ttl_days || ' days')::interval;
    v_event_threshold := now() - (p_event_retention_days || ' days')::interval;

    with deleted as (
        delete from shared_lists where created_at < v_shared_threshold returning 1
    ) select count(*) into v_shared_deleted from deleted;

    with deleted as (
        delete from events where created_at < v_event_threshold returning 1
    ) select count(*) into v_events_deleted from deleted;

    with deleted as (
        delete from sessions where last_seen < v_event_threshold returning 1
    ) select count(*) into v_sessions_deleted from deleted;

    with deleted as (
        delete from users where last_seen < v_event_threshold returning 1
    ) select count(*) into v_users_deleted from deleted;

    return jsonb_build_object(
        'sharedDeleted', v_shared_deleted,
        'eventsDeleted', v_events_deleted,
        'sessionsDeleted', v_sessions_deleted,
        'usersDeleted', v_users_deleted
    );
end;
$$ language plpgsql;

-- RPC: Get Daily Metrics
create or replace function get_daily_metrics(p_days int)
returns table (
    day text,
    dau bigint,
    sessions bigint,
    events bigint
) as $$
begin
    return query
    select
        to_char(created_at, 'YYYY-MM-DD') as day,
        count(distinct user_id) as dau,
        count(distinct session_id) as sessions,
        count(*) as events
    from events
    where created_at >= (now() - (p_days || ' days')::interval)
    group by 1
    order by 1 asc;
end;
$$ language plpgsql;

-- RPC: Get Top Events
create or replace function get_top_events(p_days int, p_limit int default 30)
returns table (
    name text,
    count bigint
) as $$
begin
    return query
    select
        e.name,
        count(*) as count
    from events e
    where created_at >= (now() - (p_days || ' days')::interval)
    group by 1
    order by 2 desc
    limit p_limit;
end;
$$ language plpgsql;

-- RPC: Get Funnel Stats
create or replace function get_funnel_stats(p_days int)
returns jsonb as $$
declare
    v_result jsonb;
begin
    with base as (
        select
            session_id,
            max(case when name = 'trip_started' then 1 else 0 end) as started,
            max(case when name = 'list_finalized' then 1 else 0 end) as finalized,
            max(case when name = 'list_shared' then 1 else 0 end) as shared,
            max(case when name = 'list_exported' then 1 else 0 end) as exported
        from events
        where created_at >= (now() - (p_days || ' days')::interval)
        group by session_id
    )
    select jsonb_build_object(
        'startedSessions', coalesce(sum(started), 0),
        'finalizedSessions', coalesce(sum(finalized), 0),
        'sharedSessions', coalesce(sum(shared), 0),
        'exportedSessions', coalesce(sum(exported), 0),
        'startedToFinalized', coalesce(sum(case when started = 1 and finalized = 1 then 1 else 0 end), 0),
        'finalizedToShared', coalesce(sum(case when finalized = 1 and shared = 1 then 1 else 0 end), 0)
    ) into v_result
    from base;

    return v_result;
end;
$$ language plpgsql;

-- RPC: Get Top Destinations (Parsing JSON payload)
create or replace function get_top_destinations(p_days int, p_limit int default 20)
returns table (
    destination text,
    count bigint
) as $$
begin
    return query
    select
        (payload->>'destination')::text as destination,
        count(*) as count
    from events
    where created_at >= (now() - (p_days || ' days')::interval)
      and name = 'trip_started'
      and payload->>'destination' is not null
      and trim(payload->>'destination') <> ''
    group by 1
    order by 2 desc
    limit p_limit;
end;
$$ language plpgsql;

-- RPC: Get Search Terms
create or replace function get_top_search_terms(p_days int, p_limit int default 20)
returns table (
    query text,
    count bigint
) as $$
begin
    return query
    select
        lower(trim(payload->>'query')) as query,
        count(*) as count
    from events
    where created_at >= (now() - (p_days || ' days')::interval)
      and name in ('items_bulk_checked_set', 'packing_bulk_set', 'packing_search_bulk_set', 'packing_scenario_bulk_set')
      and payload->>'query' is not null
      and trim(payload->>'query') <> ''
    group by 1
    order by 2 desc
    limit p_limit;
end;
$$ language plpgsql;

-- RPC: Get Template Usage
create or replace function get_template_usage(p_days int, p_limit int default 20)
returns jsonb as $$
declare
    v_selected jsonb;
    v_applied jsonb;
begin
    select jsonb_agg(sub) into v_selected from (
        select payload->>'templateId' as templateId, count(*) as count
        from events
        where created_at >= (now() - (p_days || ' days')::interval)
          and name = 'template_selected'
        group by 1 order by 2 desc limit p_limit
    ) sub;

    select jsonb_agg(sub) into v_applied from (
        select payload->>'templateId' as templateId, count(*) as count
        from events
        where created_at >= (now() - (p_days || ' days')::interval)
          and name = 'template_applied'
        group by 1 order by 2 desc limit p_limit
    ) sub;

    return jsonb_build_object(
        'selected', coalesce(v_selected, '[]'::jsonb),
        'applied', coalesce(v_applied, '[]'::jsonb)
    );
end;
$$ language plpgsql;

-- RPC: Get Recent Events
create or replace function get_recent_events(
    p_limit int default 100,
    p_name text default null,
    p_q text default null,
    p_since timestamptz default null
)
returns table (
    id bigint,
    userId text,
    sessionId text,
    name text,
    payload jsonb,
    createdAt timestamptz
) as $$
begin
    return query
    select
        e.id,
        e.user_id as userId,
        e.session_id as sessionId,
        e.name,
        e.payload,
        e.created_at as createdAt
    from events e
    where (p_since is null or e.created_at >= p_since)
      and (p_name is null or e.name = p_name)
      and (p_q is null or e.name ilike '%' || p_q || '%')
    order by e.id desc
    limit p_limit;
end;
$$ language plpgsql;

-- Enable Row Level Security (RLS)
alter table users enable row level security;
alter table sessions enable row level security;
alter table events enable row level security;
alter table shared_lists enable row level security;

-- Policies (Public access for demo/MVP, but restricted by Service Role in App)
-- Since we are using Service Role Key in the backend, we bypass RLS.
-- However, for client-side matching, we might want to restrict.
-- For now, we'll allow anon insert for events/users/sessions as that's what the public API does.

create policy "Enable insert for everyone" on events for insert with check (true);
create policy "Enable insert for everyone" on users for insert with check (true);
create policy "Enable select for everyone" on users for select using (true); -- needed for upsert check often
create policy "Enable update for everyone" on users for update using (true);
create policy "Enable insert for everyone" on sessions for insert with check (true);
create policy "Enable select for everyone" on sessions for select using (true);
create policy "Enable update for everyone" on sessions for update using (true);

-- Shared Lists: public read, public insert
create policy "Public read shared lists" on shared_lists for select using (true);
create policy "Public insert shared lists" on shared_lists for insert with check (true);

-- RPC: Get Risk KPI Stats
create or replace function get_risk_kpi(p_days int)
returns jsonb as $$
declare
    v_blocked_events bigint;
    v_cleared_events bigint;
    v_blocked_sessions bigint;
    v_cleared_sessions bigint;
    v_resolved_by_action jsonb;
    v_resolved_by_type jsonb;
    v_threshold timestamptz;
begin
    v_threshold := now() - (p_days || ' days')::interval;

    -- Basic counts
    select count(*) into v_blocked_events from events where name = 'risk_gate_blocked' and created_at >= v_threshold;
    select count(*) into v_cleared_events from events where name = 'risk_blocking_cleared' and created_at >= v_threshold;

    -- Session counts
    select count(distinct session_id) into v_blocked_sessions from events where name = 'risk_gate_blocked' and created_at >= v_threshold;
    select count(distinct session_id) into v_cleared_sessions from events where name = 'risk_blocking_cleared' and created_at >= v_threshold;

    -- Aggregate resolution actions
    select jsonb_object_agg(sub.action, sub.count) into v_resolved_by_action from (
        select (payload->>'action')::text as action, count(*) as count
        from events
        where name = 'risk_issue_resolved' and created_at >= v_threshold
        group by 1
    ) sub;

    -- Aggregate resolution types
    select jsonb_object_agg(sub.issueType, sub.count) into v_resolved_by_type from (
        select (payload->>'issueType')::text as issueType, count(*) as count
        from events
        where name = 'risk_issue_resolved' and created_at >= v_threshold
        group by 1
    ) sub;

    return jsonb_build_object(
        'blockedEvents', v_blocked_events,
        'clearedEvents', v_cleared_events,
        'blockedSessions', v_blocked_sessions,
        'clearedSessions', v_cleared_sessions,
        'clearanceRate', case when v_blocked_sessions = 0 then 0 else round(v_cleared_sessions::numeric / v_blocked_sessions::numeric, 4) end,
        'resolvedByAction', coalesce(v_resolved_by_action, '{}'::jsonb),
        'resolvedByType', coalesce(v_resolved_by_type, '{}'::jsonb)
    );
end;
$$ language plpgsql;

